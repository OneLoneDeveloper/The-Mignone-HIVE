<section class="py-10 px-3 px-sm-4 px-md-5">
  <div class="mb-4 text-center">
    <h1 class="mb-3">Area & Perimeter Relationship</h1>
    <p class="lead mx-auto" style="max-width:900px">
      Use the sliders/fields or drag the knobs on the rectangle. Lock perimeter or area to see how dimensions respond.
    </p>
  </div>

  <div class="row g-4">
    <!-- LEFT: Controls -->
    <div class="col-12 col-lg-4">
      <div class="card shadow-sm">
        <div class="card-body">
          <h2 class="h5 mb-3">Controls</h2>

          <!-- Zoom -->
          <div class="mb-3">
            <label class="form-label" for="zoomRange">Zoom</label>
            <input id="zoomRange" type="range" class="form-range" min="10" max="300" step="1" value="100" aria-label="Zoom percentage">
            <div class="form-text"><span id="zoomLabel">100%</span></div>
          </div>

          <!-- Width -->
          <div class="mb-3">
            <label class="form-label" for="widthRange">Width (cm)</label>
            <input id="widthRange" type="range" class="form-range" min="1" max="20" step="0.1" value="8">
            <input id="widthInput" type="number" class="form-control mt-2" min="1" max="20" step="0.1" value="8" aria-label="Width in centimeters">
          </div>

          <!-- Height -->
          <div class="mb-3">
            <label class="form-label" for="heightRange">Height (cm)</label>
            <input id="heightRange" type="range" class="form-range" min="1" max="20" step="0.1" value="5">
            <input id="heightInput" type="number" class="form-control mt-2" min="1" max="20" step="0.1" value="5" aria-label="Height in centimeters">
          </div>

          <!-- Locks -->
          <div class="form-check mb-2">
            <input class="form-check-input" type="checkbox" id="lockPerimeter">
            <label class="form-check-label" for="lockPerimeter">Lock perimeter</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="lockArea">
            <label class="form-check-label" for="lockArea">Lock area</label>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Visualizer -->
    <div class="col-12 col-lg-8">
      <div class="card shadow-sm">
        <div class="card-body">
          <h2 class="h5 mb-3">Visualizer</h2>
          <div class="w-100">
            <svg id="board" width="100%" height="480" viewBox="0 0 900 480" xmlns="http://www.w3.org/2000/svg"
                 style="background: rgba(255,255,255,0.6); border: 1px solid rgba(0,0,0,.1); border-radius: .5rem; touch-action: none;">
              <g id="scene" transform="translate(60,40)">
                <!-- All drawable content gets wrapped in a zoom layer -->
                <g id="zoomLayer">
                  <!-- Rectangle -->
                  <rect id="rect" x="0" y="0" width="320" height="200" rx="4" ry="4"
                        style="fill: rgba(25,135,84,.15); stroke:#198754; stroke-width:2;"></rect>

                  <!-- Knobs -->
                  <!-- Right-edge width knob (upright rectangle) -->
                  <rect id="handleW" x="320" y="80" width="10" height="40" rx="2" ry="2" style="fill:#0d6efd; cursor:ew-resize;"></rect>
                  <!-- Top-edge height knob (horizontal rectangle) -->
                  <rect id="handleH" x="140" y="200" width="40" height="10" rx="2" ry="2" style="fill:#0d6efd; cursor:ns-resize;"></rect>
                  <!-- Corner knob (little L corner) -->
                  <path id="handleCorner" d="M 304 200 L 320 200 L 320 184" style="stroke:#6f42c1; stroke-width:4; fill:none; cursor:nwse-resize; stroke-linecap:round;"></path>
                </g>
              </g>
            </svg>

            <div class="row text-nowrap">
              <div class="col-6 col-lg-3">
                <div>
                  <span>Width = </span>
                  <span id="labelW">8 cm</span>
                </div>
              </div>
              <div class="col-6 col-lg-3">
                <div>
                  <span>Height = </span>
                  <span id="labelH">5 cm</span>
                </div>
              </div>
              <div class="col-6 col-lg-3">
                <div>
                  <span>Perimeter = </span>
                  <span id="labelPerimeter">26 cm</span>
                </div>
              </div>
              <div class="col-6 col-lg-3">
                <div>
                  <span>Area = </span>
                  <span id="labelArea">40 cm²</span>
                </div>
              </div>
            </div>

          </div>
        </div>
      </div>
    </div>
  </div>
</section>


<script>
(function () {
  // ---------- Tweakable constants ----------
  const MIN_W = 0.01;     // cm
  const MIN_H = 0.01;     // cm
  const MAX_W = 200;      // cm
  const MAX_H = 200;      // cm
  const BASE_SCALE = 20;  // px per cm at 100% zoom

  // Handle sizes (in screen px; feel free to bump to 32–40 for touch)
  const HANDLE_SIDE_W = 12;  // right-edge knob width (screen px)
  const HANDLE_SIDE_H = 36;  // right-edge knob height (screen px)
  const HANDLE_TOP_W  = 36;  // top-edge knob width (screen px)
  const HANDLE_TOP_H  = 12;  // top-edge knob height (screen px)
  const CORNER_ARM    = 16;  // L-corner arm length (screen px)
  const CORNER_STROKE = 4;   // L-corner line thickness (screen px)

  // ---------- State ----------
  const state = {
    w: 8,
    h: 5,
    lockedPerimeter: 2 * (8 + 5),
    lockedArea: 8 * 5,
    constraint: 'none', // 'none' | 'perimeter' | 'area'
    zoom: 1             // 1 = 100%, range 0.1–3.0
  };

  // ---------- Elements ----------
  const wRange = document.getElementById('widthRange');
  const wInput = document.getElementById('widthInput');
  const hRange = document.getElementById('heightRange');
  const hInput = document.getElementById('heightInput');
  const lockP = document.getElementById('lockPerimeter');
  const lockA = document.getElementById('lockArea');

  const zoomRange = document.getElementById('zoomRange');
  const zoomLabel = document.getElementById('zoomLabel');

  const svg   = document.getElementById('board');
  const scene = document.getElementById('scene');
  const zoomLayer = document.getElementById('zoomLayer');
  const rect  = document.getElementById('rect');
  const labelW = document.getElementById('labelW');
  const labelH = document.getElementById('labelH');
  const labelArea = document.getElementById('labelArea');
  const labelPerimeter = document.getElementById('labelPerimeter');

  const handleW = document.getElementById('handleW');
  const handleH = document.getElementById('handleH');
  const handleCorner = document.getElementById('handleCorner');

  // Set ranges (so UI mirrors constants)
  [wRange, wInput].forEach(el => { el.min = MIN_W; el.max = MAX_W; el.step = 0.1; el.value = state.w; });
  [hRange, hInput].forEach(el => { el.min = MIN_H; el.max = MAX_H; el.step = 0.1; el.value = state.h; });

  // ---------- Helpers ----------
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const bottomLocalY = () => 400; // bottom edge in local (unscaled) coords

  function updateLabels() {
    const P = +(2 * (state.w + state.h)).toFixed(2);
    const A = +(state.w * state.h).toFixed(2);
    labelW.textContent = `${state.w.toFixed(2)} cm`;
    labelH.textContent = `${state.h.toFixed(2)} cm`;
    labelArea.textContent = `${A} cm²`;
    labelPerimeter.textContent = `${P} cm`;
  }

  // Apply zoom around the bottom-left corner of the content
  function applyZoomTransform() {
    const ax = 0;
    const ay = bottomLocalY();
    zoomLayer.setAttribute(
      'transform',
      `translate(${ax},${ay}) scale(${state.zoom}) translate(${-ax},${-ay})`
    );
  }

  // Draw geometry in base units (independent of zoom).
  // Knobs are sized inversely to zoom so they look constant on screen.
  function render() {
    const S = BASE_SCALE;
    const z = state.zoom;
    const inv = 1 / z;

    const wpx = state.w * S;
    const hpx = state.h * S;

    const BOTTOM_PX = bottomLocalY();
    const yTop = BOTTOM_PX - hpx;

    // Rectangle
    rect.setAttribute('x', 0);
    rect.setAttribute('y', yTop);
    rect.setAttribute('width', wpx);
    rect.setAttribute('height', hpx);

    // --- Handles (constant screen size via inverse scaling) ---

    // Right-edge (vertical) knob: sits just to the right of the rect
    const sideW = HANDLE_SIDE_W * inv;
    const sideH = HANDLE_SIDE_H * inv;
    handleW.setAttribute('x', wpx); // keep it outside, to the right
    handleW.setAttribute('width', sideW);
    handleW.setAttribute('height', sideH);
    handleW.setAttribute('y', yTop + (hpx - sideH) / 2);

    // Top-edge (horizontal) knob: centered on top edge
    const topW = HANDLE_TOP_W * inv;
    const topH = HANDLE_TOP_H * inv;
    handleH.setAttribute('width', topW);
    handleH.setAttribute('height', topH);
    handleH.setAttribute('x', wpx / 2 - topW / 2);
    handleH.setAttribute('y', yTop - topH / 2);

    // Corner “L” knob: arms remain constant length on screen
    const arm = CORNER_ARM * inv;
    handleCorner.setAttribute('d', `M ${wpx - arm} ${yTop} L ${wpx} ${yTop} L ${wpx} ${yTop + arm}`);

    updateLabels();
  }

  function respectConstraint(changed) {
    if (state.constraint === 'perimeter') {
      const half = state.lockedPerimeter / 2;
      if (changed === 'w' || changed === 'both') {
        let h = +(half - state.w);
        h = clamp(h, MIN_H, MAX_H);
        let w = +(half - h);
        w = clamp(w, MIN_W, MAX_W);
        state.h = +(half - w);
        state.w = +w;
      } else {
        let w = +(half - state.h);
        w = clamp(w, MIN_W, MAX_W);
        let h = +(half - w);
        h = clamp(h, MIN_H, MAX_H);
        state.w = +(half - h);
        state.h = +h;
      }
    } else if (state.constraint === 'area') {
      const A = state.lockedArea;
      if (changed === 'w' || changed === 'both') {
        let h = +(A / state.w);
        h = clamp(h, MIN_H, MAX_H);
        let w = +(A / h);
        w = clamp(w, MIN_W, MAX_W);
        state.h = +(A / w);
        state.w = +w;
      } else {
        let w = +(A / state.h);
        w = clamp(w, MIN_W, MAX_W);
        let h = +(A / w);
        h = clamp(h, MIN_H, MAX_H);
        state.w = +(A / h);
        state.h = +h;
      }
    }
  }

  function syncInputs() {
    const W = state.w.toFixed(2); wRange.value = W; wInput.value = W;
    const H = state.h.toFixed(2); hRange.value = H; hInput.value = H;
  }

  function setWidth(val, changedBy='w') {
    state.w = +clamp(parseFloat(val) || 0, MIN_W, MAX_W);
    if (state.constraint !== 'none') respectConstraint(changedBy);
    syncInputs(); render();
  }
  function setHeight(val, changedBy='h') {
    state.h = +clamp(parseFloat(val) || 0, MIN_H, MAX_H);
    if (state.constraint !== 'none') respectConstraint(changedBy);
    syncInputs(); render();
  }

  // ---------- Events: sliders & fields ----------
  wRange.addEventListener('input', e => setWidth(e.target.value, 'w'));
  wInput.addEventListener('input', e => setWidth(e.target.value, 'w'));
  hRange.addEventListener('input', e => setHeight(e.target.value, 'h'));
  hInput.addEventListener('input', e => setHeight(e.target.value, 'h'));

  // Locks (mutually exclusive)
  lockP.addEventListener('change', () => {
    if (lockP.checked) { lockA.checked = false; state.constraint = 'perimeter'; state.lockedPerimeter = +(2 * (state.w + state.h)).toFixed(2); }
    else if (!lockA.checked) state.constraint = 'none';
    render();
  });
  lockA.addEventListener('change', () => {
    if (lockA.checked) { lockP.checked = false; state.constraint = 'area'; state.lockedArea = +(state.w * state.h).toFixed(2); }
    else if (!lockP.checked) state.constraint = 'none';
    render();
  });

  // Zoom slider (10–300%): transform + re-render (so knobs resize to stay constant)
  zoomRange.addEventListener('input', (e) => {
    const pct = clamp(parseInt(e.target.value, 10) || 100, 10, 300);
    state.zoom = pct / 100;
    zoomLabel.textContent = `${pct}%`;
    applyZoomTransform();
    render(); // <-- important for constant-size knobs
  });

  // ---------- Dragging (knobs) ----------
  let dragMode = null; // 'w' | 'h' | 'both'

  // Corner stroke should not scale; also make it easy to hit
  handleCorner.setAttribute('vector-effect', 'non-scaling-stroke');
  handleCorner.setAttribute('stroke-width', CORNER_STROKE);
  handleCorner.setAttribute('pointer-events', 'stroke');

  function toLocalPoint(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const ctm = zoomLayer.getScreenCTM();
    const local = ctm ? pt.matrixTransform(ctm.inverse()) : { x: 0, y: 0 };
    return { x: local.x, y: local.y };
  }
  function startDrag(mode, e) { dragMode = mode; if (e.target.setPointerCapture) e.target.setPointerCapture(e.pointerId); }
  function moveDrag(e) {
    if (!dragMode) return;
    const p = toLocalPoint(e);
    const S = BASE_SCALE;
    const BOTTOM_PX = bottomLocalY();

    if (dragMode === 'w') {
      setWidth(p.x / S, 'w');
    } else if (dragMode === 'h') {
      setHeight((BOTTOM_PX - p.y) / S, 'h');
    } else {
      setWidth(p.x / S, 'both');
      setHeight((BOTTOM_PX - p.y) / S, 'both');
    }
  }
  function endDrag() { dragMode = null; }

  handleW.addEventListener('pointerdown', e => startDrag('w', e));
  handleH.addEventListener('pointerdown', e => startDrag('h', e));
  handleCorner.addEventListener('pointerdown', e => startDrag('both', e));
  svg.addEventListener('pointermove', moveDrag);
  document.addEventListener('pointerup', endDrag);
  document.addEventListener('pointercancel', endDrag);

  // ---------- Init ----------
  (function init() {
    zoomRange.value = 100;
    zoomLabel.textContent = '100%';
    syncInputs();
    render();
    applyZoomTransform();
  })();
})();
</script>
