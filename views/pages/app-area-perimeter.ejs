<section class="py-10 px-3 px-sm-4 px-md-5">
  <div class="mb-4 text-center">
    <h1 class="mb-3">üìê Area & Perimeter Playground</h1>
    <p class="lead mx-auto" style="max-width:900px">
      Use the sliders/fields or drag the knobs on the rectangle. Lock perimeter or area to see how dimensions respond.
    </p>
  </div>

  <div class="row g-4">
    <!-- LEFT: Controls -->
    <div class="col-12 col-lg-4">
      <div class="card shadow-sm">
        <div class="card-body">
          <h2 class="h5 mb-3">Controls</h2>

          <!-- Width -->
          <div class="mb-3">
            <label class="form-label" for="widthRange">Width (cm)</label>
            <input id="widthRange" type="range" class="form-range" min="1" max="20" step="0.1" value="8">
            <input id="widthInput" type="number" class="form-control mt-2" min="1" max="20" step="0.1" value="8" aria-label="Width in centimeters">
          </div>

          <!-- Height -->
          <div class="mb-3">
            <label class="form-label" for="heightRange">Height (cm)</label>
            <input id="heightRange" type="range" class="form-range" min="1" max="20" step="0.1" value="5">
            <input id="heightInput" type="number" class="form-control mt-2" min="1" max="20" step="0.1" value="5" aria-label="Height in centimeters">
          </div>

          <!-- Locks -->
          <div class="form-check mb-2">
            <input class="form-check-input" type="checkbox" id="lockPerimeter">
            <label class="form-check-label" for="lockPerimeter">Lock perimeter</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="lockArea">
            <label class="form-check-label" for="lockArea">Lock area</label>
          </div>

          <!-- (Optional) tweakable minimums ‚Äì adjust these in JS constants -->
          <small class="text-muted d-block mt-2">Min limits are enforced while locking to avoid extreme shapes.</small>
        </div>
      </div>
    </div>

    <!-- RIGHT: Visualizer -->
    <div class="col-12 col-lg-8">
      <div class="card shadow-sm">
        <div class="card-body">
          <h2 class="h5 mb-3">Visualizer</h2>
          <div class="w-100">
            <svg id="board" width="100%" height="480" viewBox="0 0 900 480" xmlns="http://www.w3.org/2000/svg"
                 style="background: rgba(255,255,255,0.6); border: 1px solid rgba(0,0,0,.1); border-radius: .5rem; touch-action: none;">
              <g id="scene" transform="translate(60,40)">
                <!-- Rectangle -->
                <rect id="rect" x="0" y="0" width="320" height="200" rx="4" ry="4"
                      style="fill: rgba(25,135,84,.15); stroke:#198754; stroke-width:2;"></rect>

                <!-- Labels (bigger) -->
                <text id="labelW" x="160" y="-18" text-anchor="middle" style="fill:#333; font-size:20px; font-weight:600;">w = 8 cm</text>
                <text id="labelH" x="330" y="100" style="fill:#333; font-size:20px; font-weight:600;">h = 5 cm</text>
                <!-- Area inside -->
                <text id="labelArea" x="160" y="100" text-anchor="middle" style="fill:#0f5132; font-size:18px; font-weight:600;">A = 40 cm¬≤</text>

                <!-- Knobs -->
                <!-- Right-edge width knob (upright rectangle) -->
                <rect id="handleW" x="320" y="80" width="10" height="40" rx="2" ry="2" style="fill:#0d6efd; cursor:ew-resize;"></rect>
                <!-- Bottom-edge height knob (horizontal rectangle) -->
                <rect id="handleH" x="140" y="200" width="40" height="10" rx="2" ry="2" style="fill:#0d6efd; cursor:ns-resize;"></rect>
                <!-- Corner knob (little L corner) -->
                <path id="handleCorner" d="M 304 200 L 320 200 L 320 184" style="stroke:#6f42c1; stroke-width:4; fill:none; cursor:nwse-resize; stroke-linecap:round;"></path>
              </g>
            </svg>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
<script>
(function () {
  // ---------- Tweakable constants ----------
  const MIN_W = 1;     // cm
  const MIN_H = 1;     // cm
  const MAX_W = 20;    // cm
  const MAX_H = 20;    // cm
  const SCALE = 40;    // px per cm (fixed scale)

  // ---------- State ----------
  const state = {
    w: 8,
    h: 5,
    lockedPerimeter: 2 * (8 + 5),
    lockedArea: 8 * 5,
    constraint: 'none' // 'none' | 'perimeter' | 'area'
  };

  // ---------- Elements ----------
  const wRange = document.getElementById('widthRange');
  const wInput = document.getElementById('widthInput');
  const hRange = document.getElementById('heightRange');
  const hInput = document.getElementById('heightInput');
  const lockP = document.getElementById('lockPerimeter');
  const lockA = document.getElementById('lockArea');

  const svg   = document.getElementById('board');
  const scene = document.getElementById('scene');
  const rect  = document.getElementById('rect');
  const labelW = document.getElementById('labelW');
  const labelH = document.getElementById('labelH');
  const labelArea = document.getElementById('labelArea');

  const handleW = document.getElementById('handleW');
  const handleH = document.getElementById('handleH');
  const handleCorner = document.getElementById('handleCorner');

  // Set ranges (so UI mirrors constants)
  [wRange, wInput].forEach(el => { el.min = MIN_W; el.max = MAX_W; el.step = 0.1; el.value = state.w; });
  [hRange, hInput].forEach(el => { el.min = MIN_H; el.max = MAX_H; el.step = 0.1; el.value = state.h; });

  // ---------- Helpers ----------
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

  function updateLabels() {
    const P = +(2 * (state.w + state.h)).toFixed(2);
    const A = +(state.w * state.h).toFixed(2);
    labelW.textContent = `w = ${state.w} cm`;
    labelH.textContent = `h = ${state.h} cm`;
    labelArea.textContent = `A = ${A} cm¬≤`;
  }

  function render() {
    const wpx = state.w * SCALE;
    const hpx = state.h * SCALE;

    rect.setAttribute('width', wpx);
    rect.setAttribute('height', hpx);

    // Label positions
    labelW.setAttribute('x', wpx / 2);
    labelH.setAttribute('x', wpx + 12);
    labelH.setAttribute('y', hpx / 2);
    labelArea.setAttribute('x', wpx / 2);
    labelArea.setAttribute('y', hpx / 2);

    // Knobs
    handleW.setAttribute('x', wpx);
    handleW.setAttribute('y', hpx / 2 - 20);
    handleH.setAttribute('x', wpx / 2 - 20);
    handleH.setAttribute('y', hpx);
    handleCorner.setAttribute('d', `M ${wpx - 16} ${hpx} L ${wpx} ${hpx} L ${wpx} ${hpx - 16}`);

    updateLabels();
  }

  function respectConstraint(changed) {
    // changed: 'w' | 'h' | 'both'
    if (state.constraint === 'perimeter') {
      const half = state.lockedPerimeter / 2; // w + h must equal this
      if (changed === 'w' || changed === 'both') {
        let h = +(half - state.w).toFixed(2);
        h = clamp(h, MIN_H, MAX_H);
        let w = +(half - h).toFixed(2);
        w = clamp(w, MIN_W, MAX_W);
        state.h = +(half - w).toFixed(2);
        state.w = +w.toFixed(2);
      } else { // changed === 'h'
        let w = +(half - state.h).toFixed(2);
        w = clamp(w, MIN_W, MAX_W);
        let h = +(half - w).toFixed(2);
        h = clamp(h, MIN_H, MAX_H);
        state.w = +(half - h).toFixed(2);
        state.h = +h.toFixed(2);
      }
    } else if (state.constraint === 'area') {
      const A = state.lockedArea;
      if (changed === 'w' || changed === 'both') {
        let h = +(A / state.w).toFixed(2);
        h = clamp(h, MIN_H, MAX_H);
        let w = +(A / h).toFixed(2);
        w = clamp(w, MIN_W, MAX_W);
        state.h = +(A / w).toFixed(2);
        state.w = +w.toFixed(2);
      } else { // changed === 'h'
        let w = +(A / state.h).toFixed(2);
        w = clamp(w, MIN_W, MAX_W);
        let h = +(A / w).toFixed(2);
        h = clamp(h, MIN_H, MAX_H);
        state.w = +(A / h).toFixed(2);
        state.h = +h.toFixed(2);
      }
    }
  }

  function syncInputs() {
    wRange.value = state.w; wInput.value = state.w;
    hRange.value = state.h; hInput.value = state.h;
  }

  function setWidth(val, changedBy='w') {
    state.w = +clamp(parseFloat(val) || 0, MIN_W, MAX_W).toFixed(2);
    if (state.constraint !== 'none') respectConstraint(changedBy);
    syncInputs(); render();
  }
  function setHeight(val, changedBy='h') {
    state.h = +clamp(parseFloat(val) || 0, MIN_H, MAX_H).toFixed(2);
    if (state.constraint !== 'none') respectConstraint(changedBy);
    syncInputs(); render();
  }

  // ---------- Events: sliders & fields (kept perfectly in sync) ----------
  wRange.addEventListener('input', e => setWidth(e.target.value, 'w'));
  wInput.addEventListener('input', e => setWidth(e.target.value, 'w'));
  hRange.addEventListener('input', e => setHeight(e.target.value, 'h'));
  hInput.addEventListener('input', e => setHeight(e.target.value, 'h'));

  // Locks (mutually exclusive behavior with checkboxes)
  lockP.addEventListener('change', () => {
    if (lockP.checked) { lockA.checked = false; state.constraint = 'perimeter'; state.lockedPerimeter = +(2 * (state.w + state.h)).toFixed(2); }
    else if (!lockA.checked) state.constraint = 'none';
    render();
  });
  lockA.addEventListener('change', () => {
    if (lockA.checked) { lockP.checked = false; state.constraint = 'area'; state.lockedArea = +(state.w * state.h).toFixed(2); }
    else if (!lockP.checked) state.constraint = 'none';
    render();
  });

  // ---------- Dragging (knobs) ----------
  let dragMode = null; // 'w' | 'h' | 'both'

  function toLocalPoint(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const local = pt.matrixTransform(scene.getScreenCTM().inverse());
    return { x: local.x, y: local.y };
  }
  function startDrag(mode, e) { dragMode = mode; e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId); }
  function moveDrag(e) {
    if (!dragMode) return;
    const p = toLocalPoint(e);
    if (dragMode === 'w')   setWidth(p.x / SCALE, 'w');
    if (dragMode === 'h')   setHeight(p.y / SCALE, 'h');
    if (dragMode === 'both'){ setWidth(p.x / SCALE, 'both'); setHeight(p.y / SCALE, 'both'); }
  }
  function endDrag() { dragMode = null; }

  handleW.addEventListener('pointerdown', e => startDrag('w', e));
  handleH.addEventListener('pointerdown', e => startDrag('h', e));
  handleCorner.addEventListener('pointerdown', e => startDrag('both', e));
  svg.addEventListener('pointermove', moveDrag);
  document.addEventListener('pointerup', endDrag);

  // ---------- Init ----------
  syncInputs(); render();
})();
</script>
